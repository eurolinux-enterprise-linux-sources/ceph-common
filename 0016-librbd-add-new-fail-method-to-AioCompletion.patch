From 1560268428ba1e0137b65012c9e740dbc6e7bc8f Mon Sep 17 00:00:00 2001
From: Jason Dillaman <dillaman@redhat.com>
Date: Wed, 8 Apr 2015 20:18:50 -0400
Subject: [PATCH 16/22] librbd: add new fail method to AioCompletion

Helper method to handle passing fatal errors generated within
librbd (not from the OSDs) back to the client.

Signed-off-by: Jason Dillaman <dillaman@redhat.com>
(cherry picked from commit 6d1d0c867855a96bee4c13a0c0a39a0e002ccd12)
(cherry picked from commit a8a1d2c947bf7b345c49864e8bd569bdcf39da72)

Conflicts:
	src/librbd/AioCompletion.cc: removed refs to pending AIO
	src/librbd/AioCompletion.h: removed refs to pending AIO
---
 src/librbd/AioCompletion.cc | 41 +++++++++++++++++++++++++++++++++++++++--
 src/librbd/AioCompletion.h  | 25 ++-----------------------
 2 files changed, 41 insertions(+), 25 deletions(-)

diff --git a/src/librbd/AioCompletion.cc b/src/librbd/AioCompletion.cc
index 86b5b50..531f151 100644
--- a/src/librbd/AioCompletion.cc
+++ b/src/librbd/AioCompletion.cc
@@ -5,6 +5,7 @@
 
 #include "common/ceph_context.h"
 #include "common/dout.h"
+#include "common/errno.h"
 
 #include "librbd/AioRequest.h"
 #include "librbd/internal.h"
@@ -25,7 +26,7 @@ namespace librbd {
     building = false;
     if (!pending_count) {
       finalize(cct, rval);
-      complete();
+      complete(cct);
     }
     lock.Unlock();
   }
@@ -54,6 +55,42 @@ namespace librbd {
     }
   }
 
+  void AioCompletion::complete(CephContext *cct) {
+    utime_t elapsed;
+    assert(lock.is_locked());
+    elapsed = ceph_clock_now(cct) - start_time;
+    switch (aio_type) {
+    case AIO_TYPE_READ:
+      ictx->perfcounter->tinc(l_librbd_aio_rd_latency, elapsed); break;
+    case AIO_TYPE_WRITE:
+      ictx->perfcounter->tinc(l_librbd_aio_wr_latency, elapsed); break;
+    case AIO_TYPE_DISCARD:
+      ictx->perfcounter->tinc(l_librbd_aio_discard_latency, elapsed); break;
+    case AIO_TYPE_FLUSH:
+      ictx->perfcounter->tinc(l_librbd_aio_flush_latency, elapsed); break;
+    default:
+      lderr(cct) << "completed invalid aio_type: " << aio_type << dendl;
+      break;
+    }
+
+    if (complete_cb) {
+      complete_cb(rbd_comp, complete_arg);
+    }
+    done = true;
+    cond.Signal();
+  }
+
+  void AioCompletion::fail(CephContext *cct, int r)
+  {
+    lderr(cct) << "AioCompletion::fail() " << this << ": " << cpp_strerror(r)
+               << dendl;
+    lock.Lock();
+    assert(pending_count == 0);
+    rval = r;
+    complete(cct);
+    put_unlock();
+  }
+
   void AioCompletion::complete_request(CephContext *cct, ssize_t r)
   {
     ldout(cct, 20) << "AioCompletion::complete_request() "
@@ -70,7 +107,7 @@ namespace librbd {
     int count = --pending_count;
     if (!count && !building) {
       finalize(cct, rval);
-      complete();
+      complete(cct);
     }
     put_unlock();
   }
diff --git a/src/librbd/AioCompletion.h b/src/librbd/AioCompletion.h
index aaccefe..82d3442 100644
--- a/src/librbd/AioCompletion.h
+++ b/src/librbd/AioCompletion.h
@@ -97,29 +97,8 @@ namespace librbd {
       start_time = ceph_clock_now(ictx->cct);
     }
 
-    void complete() {
-      utime_t elapsed;
-      assert(lock.is_locked());
-      elapsed = ceph_clock_now(ictx->cct) - start_time;
-      switch (aio_type) {
-      case AIO_TYPE_READ:
-	ictx->perfcounter->tinc(l_librbd_aio_rd_latency, elapsed); break;
-      case AIO_TYPE_WRITE:
-	ictx->perfcounter->tinc(l_librbd_aio_wr_latency, elapsed); break;
-      case AIO_TYPE_DISCARD:
-	ictx->perfcounter->tinc(l_librbd_aio_discard_latency, elapsed); break;
-      case AIO_TYPE_FLUSH:
-	ictx->perfcounter->tinc(l_librbd_aio_flush_latency, elapsed); break;
-      default:
-	lderr(ictx->cct) << "completed invalid aio_type: " << aio_type << dendl;
-	break;
-      }
-      if (complete_cb) {
-	complete_cb(rbd_comp, complete_arg);
-      }
-      done = true;
-      cond.Signal();
-    }
+    void complete(CephContext *cct);
+    void fail(CephContext *cct, int r);
 
     void set_complete_cb(void *cb_arg, callback_t cb) {
       complete_cb = cb;
-- 
2.1.0

